desc:VxHiddenDSP (Always-On Hidden DSP Tester)
// Approximation of VxCleaner always-on/hidden processing.
// Toggle each stage; all enabled by default.

slider1:100<0,100,1>Hidden DSP: Intensity (%)
slider2:0<-12,12,0.1>Output Gain (dB)
slider3:100<0,100,1>Vocal Sensitivity (%)
slider4:50<0,100,1>Focus (%)

@init
sr = srate;
eps = 0.000001;
pi = $pi;

// ------------------
// Biquad helpers
// ------------------
function biquad_hpf(f0, q) (
  w0 = 2 * pi * f0 / sr; cosw0 = cos(w0); alpha = sin(w0) / (2 * q);
  b0 = (1 + cosw0) / 2; b1 = -(1 + cosw0); b2 = (1 + cosw0) / 2;
  a0 = 1 + alpha; a1 = -2 * cosw0; a2 = 1 - alpha;
  this.b0 = b0 / a0; this.b1 = b1 / a0; this.b2 = b2 / a0; this.a1 = a1 / a0; this.a2 = a2 / a0;
);

function biquad_lpf(f0, q) (
  w0 = 2 * pi * f0 / sr; cosw0 = cos(w0); alpha = sin(w0) / (2 * q);
  b0 = (1 - cosw0) / 2; b1 = 1 - cosw0; b2 = (1 - cosw0) / 2;
  a0 = 1 + alpha; a1 = -2 * cosw0; a2 = 1 - alpha;
  this.b0 = b0 / a0; this.b1 = b1 / a0; this.b2 = b2 / a0; this.a1 = a1 / a0; this.a2 = a2 / a0;
);

function biquad_lowshelf(f0, q, g_db) (
  A = 10^(g_db/40); w0 = 2 * pi * f0 / sr; cosw0 = cos(w0); alpha = sin(w0) / (2 * q);
  b0 = A*((A+1)-(A-1)*cosw0+2*sqrt(A)*alpha); b1 = 2*A*((A-1)-(A+1)*cosw0); b2 = A*((A+1)-(A-1)*cosw0-2*sqrt(A)*alpha);
  a0 = (A+1)+(A-1)*cosw0+2*sqrt(A)*alpha; a1 = -2*((A-1)+(A+1)*cosw0); a2 = (A+1)+(A-1)*cosw0-2*sqrt(A)*alpha;
  this.b0 = b0 / a0; this.b1 = b1 / a0; this.b2 = b2 / a0; this.a1 = a1 / a0; this.a2 = a2 / a0;
);

function biquad_highshelf(f0, q, g_db) (
  A = 10^(g_db/40); w0 = 2 * pi * f0 / sr; cosw0 = cos(w0); alpha = sin(w0) / (2 * q);
  b0 = A*((A+1)+(A-1)*cosw0+2*sqrt(A)*alpha); b1 = -2*A*((A-1)+(A+1)*cosw0); b2 = A*((A+1)-(A-1)*cosw0-2*sqrt(A)*alpha);
  a0 = (A+1)-(A-1)*cosw0+2*sqrt(A)*alpha; a1 = 2*((A-1)-(A+1)*cosw0); a2 = (A+1)-(A-1)*cosw0-2*sqrt(A)*alpha;
  this.b0 = b0 / a0; this.b1 = b1 / a0; this.b2 = b2 / a0; this.a1 = a1 / a0; this.a2 = a2 / a0;
);

function biquad_peaking(f0, q, g_db) (
  A = 10^(g_db/40); w0 = 2 * pi * f0 / sr; cosw0 = cos(w0); alpha = sin(w0) / (2 * q);
  b0 = 1 + alpha * A; b1 = -2 * cosw0; b2 = 1 - alpha * A;
  a0 = 1 + alpha / A; a1 = -2 * cosw0; a2 = 1 - alpha / A;
  this.b0 = b0 / a0; this.b1 = b1 / a0; this.b2 = b2 / a0; this.a1 = a1 / a0; this.a2 = a2 / a0;
);

function biquad_process(x) (
  y = this.b0*x + this.b1*this.x1 + this.b2*this.x2 - this.a1*this.y1 - this.a2*this.y2;
  this.x2 = this.x1; this.x1 = x; this.y2 = this.y1; this.y1 = y; y;
);

function clamp(v, lo, hi) ( v < lo ? lo : (v > hi ? hi : v); );

// ------------------
// Filter init
// ------------------
hpf90_l.biquad_hpf(90, 0.707); hpf90_r.biquad_hpf(90, 0.707);
rumble_l.biquad_hpf(20, 0.707); rumble_r.biquad_hpf(20, 0.707);
safety_l.biquad_hpf(80, 0.707); safety_r.biquad_hpf(80, 0.707);

plosive_l.biquad_lowshelf(150, 0.707, 0); plosive_r.biquad_lowshelf(150, 0.707, 0);

pink_lo_l.biquad_lowshelf(250, 0.707, 0); pink_lo_r.biquad_lowshelf(250, 0.707, 0);
pink_hi_l.biquad_highshelf(4000, 0.707, 0); pink_hi_r.biquad_highshelf(4000, 0.707, 0);

rec_presence_l.biquad_highshelf(2500, 0.707, 0); rec_presence_r.biquad_highshelf(2500, 0.707, 0);
rec_air_l.biquad_highshelf(10000, 0.707, 0); rec_air_r.biquad_highshelf(10000, 0.707, 0);

// Broad-spectrum demud (gentle)
demud_l.biquad_peaking(350, 0.7, 0); demud_r.biquad_peaking(350, 0.7, 0);

// Focus shaping (broadband polish)
focus_bass_l.biquad_lowshelf(120, 0.707, 0); focus_bass_r.biquad_lowshelf(120, 0.707, 0);
focus_mid_l.biquad_peaking(900, 0.7, 0); focus_mid_r.biquad_peaking(900, 0.7, 0);
focus_presence_l.biquad_peaking(3000, 0.9, 0); focus_presence_r.biquad_peaking(3000, 0.9, 0);
focus_air_l.biquad_highshelf(10000, 0.707, 0); focus_air_r.biquad_highshelf(10000, 0.707, 0);

guard_low_l.biquad_lowshelf(500, 0.707, 0); guard_low_r.biquad_lowshelf(500, 0.707, 0);
guard_high_l.biquad_highshelf(8000, 0.707, 0); guard_high_r.biquad_highshelf(8000, 0.707, 0);

// analysis band filters
speech_hp_l.biquad_hpf(250, 0.707); speech_hp_r.biquad_hpf(250, 0.707);
speech_lp_l.biquad_lpf(4000, 0.707); speech_lp_r.biquad_lpf(4000, 0.707);

lowmid_hp_l.biquad_hpf(200, 0.707); lowmid_hp_r.biquad_hpf(200, 0.707);
lowmid_lp_l.biquad_lpf(500, 0.707); lowmid_lp_r.biquad_lpf(500, 0.707);

high_hp_l.biquad_hpf(8000, 0.707); high_hp_r.biquad_hpf(8000, 0.707);
high_lp_l.biquad_lpf(16000, 0.707); high_lp_r.biquad_lpf(16000, 0.707);

// ------------------
// Ballistics
// ------------------
sc_atk = 1 - exp(-1 / (sr * 0.015));
sc_rel = 1 - exp(-1 / (sr * 0.120));

pink_smooth = 1 - exp(-1 / (sr * 2.0));

pl_atk = 1 - exp(-1 / (sr * 0.001));
pl_rel = 1 - exp(-1 / (sr * 0.050));

rec_atk = 1 - exp(-1 / (sr * 0.150));
rec_rel = 1 - exp(-1 / (sr * 0.060));

guard_smooth = 1 - exp(-1 / (sr * 0.050));

lim_atk = 1 - exp(-1 / (sr * 0.0001));
lim_rel = 1 - exp(-1 / (sr * 0.400));

lcomp_alpha = 1 - exp(-1 / (sr * 10.0));
hpf_update_counter = 0;


@sample
inL = spl0; inR = spl1;

// ===== Speech confidence (simple) =====
spL = speech_lp_l.biquad_process(speech_hp_l.biquad_process(inL));
spR = speech_lp_r.biquad_process(speech_hp_r.biquad_process(inR));
sp = 0.5 * (spL*spL + spR*spR);
full = 0.5 * (inL*inL + inR*inR);
ratio = sp / (full + eps);
raw_sc = clamp((ratio - 0.15) * 4.0, 0, 1);
raw_sc > sc_env ? sc_env += (raw_sc - sc_env) * sc_atk : sc_env += (raw_sc - sc_env) * sc_rel;

// ===== Fullband envelope (music-friendly) =====
raw_fb = clamp((full * 20), 0, 1);
raw_fb > fb_env ? fb_env += (raw_fb - fb_env) * sc_atk : fb_env += (raw_fb - fb_env) * sc_rel;

// Blend speech vs fullband envelope
vocal_sens = clamp(slider3 / 100, 0, 1);
intensity = clamp(slider1 / 100, 0, 1);
focus_amt = clamp(slider4 / 100, 0, 1);

// Hard bypass when intensity is zero (no hidden DSP)
intensity <= 0.0005 ? (
  out_gain = 10^(slider2 / 20);
  spl0 = inL * out_gain;
  spl1 = inR * out_gain;
  0 ? (nop); // keep JSFX parser happy
) : (
sc_mix = fb_env + (sc_env - fb_env) * vocal_sens;
strength_sens = vocal_sens;

// ===== Stage 1: Speech HPF =====
// Scale HPF cutoffs with intensity to avoid parallel phase issues.
hpf_update_counter = (hpf_update_counter + 1) % 32;
hpf_update_counter == 0 ? (
  hpf90_cut = 5 + intensity * (90 - 5);
  rumble_cut = 5 + intensity * (20 - 5);
  safety_cut = 5 + intensity * (80 - 5);
  hpf90_l.biquad_hpf(hpf90_cut, 0.707); hpf90_r.biquad_hpf(hpf90_cut, 0.707);
  rumble_l.biquad_hpf(rumble_cut, 0.707); rumble_r.biquad_hpf(rumble_cut, 0.707);
  safety_l.biquad_hpf(safety_cut, 0.707); safety_r.biquad_hpf(safety_cut, 0.707);
);
stageL = hpf90_l.biquad_process(inL);
stageR = hpf90_r.biquad_process(inR);

// ===== Stage 2: Rumble HPF =====
stageL = rumble_l.biquad_process(stageL);
stageR = rumble_r.biquad_process(stageR);

// ===== Stage 3: Pink Bias (approx tilt) =====
// Use low-mid vs high band ratio to create gentle tilt.
lowL = lowmid_lp_l.biquad_process(lowmid_hp_l.biquad_process(stageL));
lowR = lowmid_lp_r.biquad_process(lowmid_hp_r.biquad_process(stageR));
hiL = high_lp_l.biquad_process(high_hp_l.biquad_process(stageL));
hiR = high_lp_r.biquad_process(high_hp_r.biquad_process(stageR));

rms_low = 0.99 * rms_low + 0.01 * (0.5*(lowL*lowL + lowR*lowR));
rms_hi = 0.99 * rms_hi + 0.01 * (0.5*(hiL*hiL + hiR*hiR));

// target ratio around 1.0; error drives shelves
err = log(rms_low + eps) - log(rms_hi + eps);
// map err to +/-2 dB max, gate timing uses sc_mix but strength uses sc_env
pink_db = clamp(err * 0.8, -2.0, 2.0) * sc_env * strength_sens * intensity;
// smooth tilt
pink_smoothed += (pink_db - pink_smoothed) * pink_smooth;

abs(pink_smoothed - pink_cur) > 0.05 ? (
  pink_cur = pink_smoothed;
  pink_lo_l.biquad_lowshelf(250, 0.707, 0.9 * pink_cur);
  pink_lo_r.biquad_lowshelf(250, 0.707, 0.9 * pink_cur);
  pink_hi_l.biquad_highshelf(4000, 0.707, 1.0 * pink_cur);
  pink_hi_r.biquad_highshelf(4000, 0.707, 1.0 * pink_cur);
);
stageL = pink_hi_l.biquad_process(pink_lo_l.biquad_process(stageL));
stageR = pink_hi_r.biquad_process(pink_lo_r.biquad_process(stageR));

// ===== Stage 4: Plosive Softener =====
// Fast envelope and low-shelf attenuation up to 8 dB
p_env = 0.5 * (abs(stageL) + abs(stageR));
p_env > pl_env ? pl_env += (p_env - pl_env) * pl_atk : pl_env += (p_env - pl_env) * pl_rel;
over = max(0, pl_env - 0.08);
p_target = min(8, over * 20) * intensity;
abs(p_target - pl_cur) > 0.1 ? (
  pl_cur = p_target;
  plosive_l.biquad_lowshelf(150, 0.707, -pl_cur);
  plosive_r.biquad_lowshelf(150, 0.707, -pl_cur);
);
stageL = plosive_l.biquad_process(stageL);
stageR = plosive_r.biquad_process(stageR);

// ===== Stage 4b: Broad-spectrum Demud (gentle, intensity-scaled) =====
demud_db = -1.5 * intensity;
abs(demud_db - demud_cur) > 0.05 ? (
  demud_cur = demud_db;
  demud_l.biquad_peaking(350, 0.7, demud_cur);
  demud_r.biquad_peaking(350, 0.7, demud_cur);
);
stageL = demud_l.biquad_process(stageL);
stageR = demud_r.biquad_process(stageR);

// ===== Stage 5: Safety HPF =====
stageL = safety_l.biquad_process(stageL);
stageR = safety_r.biquad_process(stageR);

// ===== Stage 6: Recovery (speech gated) =====
rec_pres = 1;
rec_air = 1;
(
  // gate thresholds scale down as recovery amount decreases,
  // but keep a small floor to avoid sudden dropout.
  gate_amt = max(rec_pres, rec_air);
  gate_on = 0.05 + 0.10 * gate_amt;
  gate_full = 0.20 + 0.35 * gate_amt;
  gate_full <= gate_on ? gate_full = gate_on + 0.001;
  gate_pos = sc_mix >= gate_full ? 1 : (sc_mix <= gate_on ? 0 : (sc_mix - gate_on) / (gate_full - gate_on));
  // soften gate edge
  gate_pos = gate_pos * gate_pos * (3 - 2 * gate_pos);
  // gate timing uses sc_mix, strength uses sc_env to keep tonal balance consistent
  rec_strength = sc_env * strength_sens * intensity;
  rec_target_p = gate_pos * rec_pres * rec_strength;
  rec_target_a = gate_pos * rec_air * rec_strength;
  rec_target_p > rec_env_p ? rec_env_p += (rec_target_p - rec_env_p) * rec_atk : rec_env_p += (rec_target_p - rec_env_p) * rec_rel;
  rec_target_a > rec_env_a ? rec_env_a += (rec_target_a - rec_env_a) * rec_atk : rec_env_a += (rec_target_a - rec_env_a) * rec_rel;
  rec_p = 1.5 + (1.0 * rec_env_p); // 1.5..2.5 dB
  rec_a = 2.0 + (2.0 * rec_env_a); // 2.0..4.0 dB
  abs(rec_p - rec_p_cur) > 0.05 ? (
    rec_p_cur = rec_p;
    rec_presence_l.biquad_highshelf(2500, 0.707, rec_p_cur);
    rec_presence_r.biquad_highshelf(2500, 0.707, rec_p_cur);
  );
  abs(rec_a - rec_a_cur) > 0.05 ? (
    rec_a_cur = rec_a;
    rec_air_l.biquad_highshelf(10000, 0.707, rec_a_cur);
    rec_air_r.biquad_highshelf(10000, 0.707, rec_a_cur);
  );
  stageL = rec_air_l.biquad_process(rec_presence_l.biquad_process(stageL));
  stageR = rec_air_r.biquad_process(rec_presence_r.biquad_process(stageR));
);

// ===== Stage 7: Spectral Guardrails =====
// Removed per user request.

// ===== Stage 7b: Focus Shaping (broadband polish) =====
focus = focus_amt;
// Bass restore (up to +4 dB @ 90 Hz)
focus_bass_db = 4.0 * focus;
abs(focus_bass_db - focus_bass_cur) > 0.05 ? (
  focus_bass_cur = focus_bass_db;
  focus_bass_l.biquad_lowshelf(90, 0.707, focus_bass_cur);
  focus_bass_r.biquad_lowshelf(90, 0.707, focus_bass_cur);
);
// Low-mid demud (up to -2 dB @ 280 Hz)
focus_mid_db = -2.0 * focus;
abs(focus_mid_db - focus_mid_cur) > 0.05 ? (
  focus_mid_cur = focus_mid_db;
  focus_mid_l.biquad_peaking(280, 0.8, focus_mid_cur);
  focus_mid_r.biquad_peaking(280, 0.8, focus_mid_cur);
);
// Presence lift (up to +2 dB @ 3.2 kHz)
focus_pres_db = 2.0 * focus;
abs(focus_pres_db - focus_pres_cur) > 0.05 ? (
  focus_pres_cur = focus_pres_db;
  focus_presence_l.biquad_peaking(3200, 0.9, focus_pres_cur);
  focus_presence_r.biquad_peaking(3200, 0.9, focus_pres_cur);
);
// Air lift (up to +2 dB @ 12 kHz)
focus_air_db = 2.0 * focus;
abs(focus_air_db - focus_air_cur) > 0.05 ? (
  focus_air_cur = focus_air_db;
  focus_air_l.biquad_highshelf(12000, 0.707, focus_air_cur);
  focus_air_r.biquad_highshelf(12000, 0.707, focus_air_cur);
);
stageL = focus_air_l.biquad_process(
           focus_presence_l.biquad_process(
             focus_mid_l.biquad_process(
               focus_bass_l.biquad_process(stageL))));
stageR = focus_air_r.biquad_process(
           focus_presence_r.biquad_process(
             focus_mid_r.biquad_process(
               focus_bass_r.biquad_process(stageR))));

// ===== Stage 8: Limiter =====
postL = stageL; postR = stageR;
(
  pk = max(abs(postL), abs(postR));
  pk > lim_env ? lim_env += (pk - lim_env) * lim_atk : lim_env += (pk - lim_env) * lim_rel;
  ceiling = 0.98;
  lim_g = lim_env > ceiling ? ceiling / lim_env : 1;
  lim_gain += (lim_g - lim_gain) * 0.05;
  lim_mix = 1 - intensity + intensity * lim_gain;
  postL *= lim_mix; postR *= lim_mix;
);

// ===== Stage 9: Loudness compensation =====
(
  in_q = lcomp_alpha * in_q + (1-lcomp_alpha) * (0.5*(inL*inL + inR*inR));
  out_q = lcomp_alpha * out_q + (1-lcomp_alpha) * (0.5*(postL*postL + postR*postR));
  l_target = (in_q > eps && out_q > eps) ? clamp(sqrt(in_q / out_q), 0.9, 1.1) : 1;
  l_gain += (l_target - l_gain) * 0.001;
  l_mix = 1 - intensity + intensity * l_gain;
  postL *= l_mix; postR *= l_mix;
);

// ===== Output Gain (always) =====
out_gain = 10^(slider2 / 20);
postL *= out_gain; postR *= out_gain;

// ===== Stage 10: Output clamp =====
(
  abs_pk = max(abs(postL), abs(postR));
  abs_pk > 4 ? (
    scale = 4 / abs_pk;
    postL *= scale; postR *= scale;
  );
);

// hard safety clamp (always)
postL = clamp(postL, -1.2, 1.2);
postR = clamp(postR, -1.2, 1.2);

// Output (no parallel mix to avoid phase cancellation)
spl0 = postL;
spl1 = postR;
); // end intensity bypass else
